Здравствуйте! 
Я Михаил Чистяков, студент БГУИР из группы 550501. Высылаю сделанную 5 лабораторную работу по СПОВМ.
Делал задание только под Linux, но в усложнённом варианте. 
Базовый вариант (привожу задание из практикума без изменений):
	В каталоге имеется набор текстовых файлов. Необходимо разработать приложение из двух потоков, которые работают по следующей схеме:
		1) первый поток (поток-читатель) асинхронным образом считывает содержимое одного файла;
		2) поток-читатель уведомляет второй поток (поток-писатель) о том, что содержимое файла прочитано и может быть передано писателю;
		3) поток-писатель получает от потока-читателя содержимое файла и асинхронным образом записывает полученную строку в конец выходного файла;
		4) поток-читатель получает уведомление от потока-писателя о том, что строка записана в выходной файл и можно приступать к чтению следующего файла;
		5) процедура повторяется с п.1, пока не закончится список файлов.
	В результате должна быть произведена конкатенация (объединение) входных текстовых файлов в один результирующий. Функции чтения-записи должны быть выделены в динамическую библиотеку, подключены на этапе выполнения программы и выгружены после отработки основного цикла.
Выполненный мной вариант:
	В предложенной схеме выполнения я увидел 2 недостатка, которые пытался устранить в первую очередь:
		1) Нет использования преимуществ ни аснхронной обработки IO, ни многопоточности вообще. Читатель и писатель ожидают друг друг друга и не выполняют полезной работы во время асинхронного IO.
		2) Файлы считываются и записываются целиком. 
	В итоге получились следующие усложнения:
		* Созданная динамическая библиотека позволяет добавлять файлы для конкатенации во время конкатенации других
		* Задача конкатенации производятся одновременно над всеми входными файлами
		* Есть возможность узнать прогресс конкатенации каждого файла

Интерфейс библиотки для пользователя (extern const struct zox_aio ZOX_AIO с полями-ссылками на функции):
	Цель конкатенации выделена в абстракцию "конекст". Самое главное, что идентифицирует конекст — выходной файл. Сначала пользователь получает из библиотеки контекст, затем добавляет в него задачи — файлы-слагаемые. При добавлении задачи её id возвращается пользователю, по которому потом можно будет получить прогресс выполнения. После завершения работы конексsт необходимо закрыть. 

Архитектура библиотеки изнутри:
	Работу выполняют связанные с контекстом (src/zox_aio/zox_aio_context.h) потоки (src/zox_aio/task_executor/(reader|writer)). Работа потоков организована с помощью очередей сообщений (glib queue), своих для каждого потока. Каждое сообщение — либо NULL (тогда поток должен завершить свою работу), либо указатель на задачу (src/zox_aio/zox_aio_task.h). При создании задачи для неё создаётся отдельная структура aiocb, обновляется предполагаемый размер результирующего файла и устанавливаются смещения чтения и записи. Потоки при получении в свои очереди конфигурируют aiocb нужным образом и запускают соответствующую асинхронную операцию. Поток читатель помимо этого выполняет проверку на завершение (и на то, что читать осталось меньше, чем размер буффера), а писатель обновляет для задачи поле количества записанных буфферов (необходимо для вычисления текущего прогресса). Кроме того, читатель и писатель настраивают aiocb так, чтобы по завершении вызывалась функция, которая добавит сообщение в очередь нужного потока (читатель уведомит писателя, писатель — читателя). 
	Таким образом, читатель ожидает завершённых задач записи, асинхронно запускает её для записи и приступает к анализу следующей задачи, если она есть в его очереди. Завершённая задача записи уведомляет писателя, который работает аналогично.
	Я заметил, что механика работы у писателя и читателя практически одинакова, поэтому вынес механизм очереди сообщений и управления жизнью в абстракцию executor (src/zox_aio/task_executor/task_executor.h) (что-то вроде интерфейса/суперкласса). При создании читатель и писатель возвращают executor, определив в нём функцию анализа поступившего сообщения. 

Что происходит в клиенте (main.c):
	1) Открытие библиотеки и создание контекста
	2) Парсинг аргументов командной строки
	3) Поиск файлов *.part в текущей директории
	4) Запуск задач
	5) Мониторинг задач до полного выполнения
	6) Очистка ресурсов

Руководство к запуску:
	1) make
	2) cd test
	3.1) lab5 
	3.2) lab5 -f result.txt -d 200