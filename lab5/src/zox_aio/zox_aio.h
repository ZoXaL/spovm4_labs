#ifndef ZOX_AIO_H
#define ZOX_AIO_H

struct zox_aio_context;
typedef struct zox_aio_context zox_aio_context;

typedef struct zox_aio_settings {
	const char* target_file;
	int ms_delay;
	int buffer_size;
	int is_debug_enabled;
} zox_aio_settings;

struct zox_aio {
	int (*initialize_context)(zox_aio_context**, zox_aio_settings);// инициализация и получение контекста
	void (*destroy_context)(zox_aio_context*); // уничтожение конекста, установка флага убийства
	int (*add_task)(zox_aio_context*, const char* file); // добавление файла для конкатенации
	int (*get_task_progress)(zox_aio_context*, int task_id);
	const char* (*get_task_filename)(zox_aio_context*, int task_id);
};

extern const struct zox_aio ZOX_AIO;
#endif



/*
Бибилиотека для конкатенации нескольких файлов в один результирующий. Файлы одновременно копируются в нужные позиции в результирующем файле, используя асинхронные вызовы и буферы небольшого размера для каждого копируемого файла. За ходом выполнения копирования каждого файла можно отслеживать.
Порядок работы с библиотекой:
* создаётся конекст задачи, для создания необходим путь к результируюему файлу
* добавляются задачи в созданный контекст, которые представляют собой пути к файлам для конкатенации
* состояние задач отслеживается, для каждой задачи можно получить процент завершённости
* контекст закрывается
Принципы работы библиотеки:
* при инициализации контекст создаёт два потока, писатель и читатель
* при закрытии контекст инициирует закрытие двух своих рабочих потоков
* контекст хранит кольцо задач zox_aio_task


Добавление задачи в конекст производится в исходном вызывающем потоке. 
* Получить файловый дескриптор, вернуть ошибку при проблеме
* Получить размер файла
* Выделить буффер для работы задачи
* создать aiocb
* атомарно добавить в кольцо задачу

Поток-писатель и поток-читатель имеют общее кольцо для хранения задач конкатенации. 
Поток-писатель и поток-читатель имеют свои личные очереди для уведомлений. Уведомление говорит о завершении операции (чтение/запись) над некоторым файлом.

Порядок работы потока-читателя:
* ожидать поступления уведомления/убийства 
* запустить задачу чтения/умереть. Задача при завершении посылает уведомление писателю

Порядок работы потока-читателя:
* ожидать поступления уведомления/убийства 
* запустить задачу записи/умереть. Задача при завершении посылает уведомление читателю


Нужно загуглить:
* получить все файлы из текущей директории
+ glib структуры данных, нужена очередь и кольцо


Minimal working example:
1) main создаёт контекст для одного фиксированного файла
2) main добавляет на запись один файл
3) main в цикле опроса проверяет завершённость
4) main убивает контекст

*/